# Task 1: Information about io_uring source
List in this section source and headers of io_uring. For each of the C source/header, you must put description what's the prime responsibily of the source. Take notes, description of the source should be slightly technical like the example given. 

## Source
### advice.c
Memproses permintaan advice terkait manajemen cache file (fadvise) dan manajemen memori (madvise) melalui mekanisme io_uring, di mana io_fadvise menggunakan vfs_fadvise untuk memberikan saran pada cache file system (seperti pola akses data), sedangkan io_madvise menggunakan do_madvise untuk memberikan saran pada manajemen memori virtual (seperti pembebasan memori). Kedua operasi ini diproses secara asinkronus dengan pengecekan kondisi tertentu seperti REQ_F_FORCE_ASYNC dan hanya io_madvise yang dikendalikan oleh flag kompilasi CONFIG_ADVISE_SYSCALLS dan CONFIG_MMU. 

### alloc_cache.c
Mengelola alokasi dan dealokasi memori dalam cache menggunakan struktur io_alloc_cache, di mana fungsi io_alloc_cache_init menginisialisasi cache dengan mengalokasikan array pointer menggunakan kvmalloc_array dan mengatur parameter seperti jumlah maksimum elemen (max_cached), ukuran elemen (elem_size), dan byte inisialisasi (init_clear), sementara io_alloc_cache_free membebaskan semua entri dalam cache dengan memanggil fungsi free yang diberikan untuk setiap elemen sebelum membebaskan array cache itu sendiri dengan kvfree, dan io_cache_alloc_new mengalokasikan objek baru menggunakan kmalloc dan menginisialisasi memori dengan nol jika init_clear diatur.

### cancel.c
Menangani operasi pembatalan asinkron dalam modul io_uring Linux, di mana ia menyediakan fungsi untuk mencocokkan dan membatalkan permintaan I/O berdasarkan kriteria seperti file descriptor, opcode, atau user data, dengan menggunakan struktur io_cancel_data untuk menentukan parameter pembatalan dan melakukan pencarian baik secara lokal pada io_wq pekerja saat ini maupun secara global pada semua pekerja melalui mekanisme lock-protected tctx_list, sambil juga menangani kasus edge seperti pembatalan timeout, poll, waitid, dan futex melalui fallback ke fungsi spesifik masing-masing.

### epoll.c
Mengimplementasikan fungsi epoll dalam io_uring, yang memungkinkan operasi epoll_ctl dan epoll_wait dijalankan secara asinkron melalui io_uring. Kode ini mendefinisikan dua struktur utama, io_epoll untuk operasi epoll_ctl (mengontrol file descriptor yang dimonitor) dan io_epoll_wait untuk operasi epoll_wait (menunggu event), serta menyediakan fungsi persiapan (*_prep) dan eksekusi untuk masing-masing operasi. Fungsi io_epoll_ctl memproses permintaan epoll_ctl dengan dukungan mode non-blocking, sementara io_epoll_wait mengirimkan event yang terjadi ke user space melalui mekanisme io_uring, dengan penanganan error dan hasil yang sesuai.

### eventfd.c
Mengelola integrasi antara eventfd dan io_uring, di mana fungsionalitas utamanya adalah memungkinkan notifikasi asinkron melalui eventfd ketika operasi I/O di io_uring selesai. Struktur io_ev_fd menyimpan konteks eventfd (cq_ev_fd) dan informasi terkait seperti status async (eventfd_async), referensi (refs), serta sinkronisasi menggunakan mekanisme RCU dan spinlock. Fungsi seperti io_eventfd_signal dan io_eventfd_flush_signal digunakan untuk memicu notifikasi eventfd ketika ada penyelesaian operasi I/O, sementara io_eventfd_register dan io_eventfd_unregister mengatur pendaftaran dan pelepasan eventfd dari konteks io_uring, dengan penanganan yang aman terhadap race condition menggunakan RCU dan lock.

### fdinfo.c
Menampilkan informasi file descriptor (fdinfo) terkait io_uring, sebuah antarmuka asinkron I/O di Linux, dengan mengekspos detail seperti status submission queue (SQ) dan completion queue (CQ), termasuk head/tail, mask, dan entri individual, serta informasi tambahan seperti SQ polling thread, file pengguna, buffer, dan kredensial, dimana beberapa bagian kode hanya aktif jika macro konfigurasi tertentu (seperti CONFIG_PROC_FS atau CONFIG_NET_RX_BUSY_POLL) diaktifkan selama kompilasi.

### filetable.c
Mengelola alokasi dan dealokasi file descriptor tetap (fixed file descriptors) dalam modul io_uring Linux, di mana fungsi utamanya mencakup pengelolaan bitmap untuk melacak slot file yang tersedia, instalasi file ke slot tetap, serta penanganan range alokasi file. Modul ini menggunakan struktur io_file_table untuk menyimpan bitmap dan data resource, dengan fungsi seperti io_file_bitmap_get untuk mencari slot kosong, io_install_fixed_file untuk mengaitkan file dengan slot tertentu, dan io_fixed_fd_remove untuk melepaskan resource. Selain itu, kode ini memastikan thread-safety dengan menggunakan lock (io_ring_submit_lock) selama operasi kritis dan menangani kasus error seperti overflow atau slot invalid.

### fs.c
Menangani operasi filesystem asinkron seperti rename, unlink, mkdir, symlink, dan link. Setiap operasi diimplementasikan melalui struktur khusus (seperti io_rename, io_unlink, dll.) yang menyimpan parameter operasi, fungsi preparasi (_prep) untuk memvalidasi dan mempersiapkan request, fungsi eksekusi asinkron (seperti io_renameat), serta fungsi cleanup untuk membebaskan resource. Kode ini memanfaatkan mekanisme io_uring untuk melakukan operasi filesystem secara efisien tanpa blocking, dengan penanganan error yang tepat dan manajemen memori yang aman melalui getname/putname.

### futex.c
Implementasi futex (fast userspace mutex) yang bertanggung jawab untuk menangani operasi-operasi sinkronisasi antar proses secara efisien di userspace. File ini mendefinisikan struktur data io_futex dan io_futex_data untuk menyimpan state futex, menyediakan fungsi-fungsi seperti io_futex_wait untuk menunggu suatu kondisi dan io_futex_wake untuk membangunkan thread yang menunggu, serta mengelola cache alokasi objek futex melalui io_futex_cache_init dan io_futex_cache_free. Implementasi ini mendukung baik operasi futex tunggal maupun multiple (vektor), dengan penanganan kasus-kasus seperti pembatalan operasi (io_futex_cancel) dan penyelesaian asinkron melalui task work.

### io-wq.c
Mengelola dan menjalankan pekerjaan asinkron secara efisien dengan memanfaatkan thread worker yang terbagi menjadi dua kategori: worker bound (terikat CPU tertentu) dan unbound (tidak terikat). Sistem ini menggunakan struktur data seperti hash table untuk mengelola pekerjaan, linked list untuk antrian pekerjaan, serta mekanisme wake-up dan sleep untuk mengoptimalkan penggunaan resource. Worker thread akan mengeksekusi pekerjaan dari antrian, dengan kemampuan untuk membatasi paralelisme pekerjaan yang di-hash ke nilai yang sama, serta mendukung pembatalan pekerjaan dan penyesuaian dinamik jumlah worker berdasarkan beban kerja.

### io_uring.c
Implementasi io_uring, mekanisme I/O asinkron berkinerja tinggi di Linux yang memungkinkan aplikasi melakukan operasi I/O dengan overhead rendah melalui pasangan ring buffer (submission dan completion queue) yang dibagi antara kernel dan user space, mendukung fitur seperti SQ polling, manajemen sumber daya, sinkronisasi memori, timeout, pembatalan operasi, dan integrasi dengan task_work kernel untuk eksekusi asinkron yang efisien.

### kbuf.c
Mengelola buffering data dalam operasi I/O asinkron, khususnya menyediakan mekanisme untuk menyediakan, memilih, dan mengembalikan buffer yang digunakan dalam operasi baca/tulis melalui io_uring. Kode ini menangani dua jenis buffer: legacy buffers (buffer tradisional yang dikelola via linked list) dan buffer rings (struktur berbentuk ring buffer yang lebih efisien). Fungsi utamanya meliputi alokasi/dealokasi buffer (io_provide_buffers, io_remove_buffers), seleksi buffer saat operasi I/O (io_buffer_select), serta manajemen metadata buffer seperti registrasi grup buffer (io_register_pbuf_ring) dan tracking status buffer. Implementasi ini memanfaatkan locking (uring_lock, mmap_lock) dan struktur data seperti XArray untuk mengelola buffer secara thread-safe, serta optimasi seperti commit inkremental untuk mengurangi overhead.

### memmap.c
Mengelola memori yang dipetakan (memory-mapped regions) dalam modul io_uring Linux, dengan fungsi utama seperti mengalokasikan halaman memori (baik dari kernel maupun user space), mem-pin halaman user space, memetakan region ke alamat virtual kernel melalui vmap, serta menangani operasi mmap untuk mengakses region tersebut dari user space. Kode ini menangani berbagai jenis region seperti ring buffers SQ/CQ, parameter, dan buffer pools, dengan mekanisme validasi dan proteksi yang ketat termasuk pengecekan overflow, pengelolaan referensi halaman, serta sinkronisasi menggunakan mmap_lock untuk keamanan multi-threading.

### msg_ring.c
Memungkinkan komunikasi dan pertukaran data antar-context io_uring melalui operasi IORING_MSG_DATA untuk mengirim data dan IORING_MSG_SEND_FD untuk mengirim file descriptor, dengan penanganan sinkronisasi yang melibatkan penguncian context target (io_lock_external_ctx), alokasi request (io_msg_get_kiocb), serta mekanisme task work (io_msg_tw_complete) untuk operasi asinkron, termasuk validasi flags dan pengecekan kondisi seperti IORING_SETUP_R_DISABLED atau konteks IOPOLL.

### napi.c
Mengimplementasikan fungsionalitas NAPI (New API) busy polling dalam io_uring, yang memungkinkan polling efisien untuk paket jaringan dengan mengurangi overhead interupsi. Modul ini menyediakan manajemen entri NAPI melalui hash table dan linked list, dengan dua mode pelacakan (static dan dynamic), di mana mode static mempertahankan entri secara permanen sementara mode dynamic membersihkan entri yang kadaluarsa setelah timeout. Fungsi utama termasuk menambah/menghapus ID NAPI, menjalankan busy loop polling dengan timeout yang dapat dikonfigurasi, serta handle registrasi/unregistrasi NAPI melalui syscall io_uring, dengan dukungan untuk preferensi busy polling dan penyesuaian parameter waktu polling.

### net.c
Implementasi operasi jaringan asinkron dalam modul io_uring yang menangani berbagai operasi socket seperti send, recv, accept, connect, bind, dan listen dengan dukungan zero-copy, multishot, dan fitur canggih lainnya. Fungsi utamanya adalah menyediakan antarmuka berkinerja tinggi untuk operasi I/O jaringan dengan meminimalkan overhead sistem dan memungkinkan penanganan permintaan secara paralel melalui mekanisme completion queue dan submission queue yang efisien. Kode ini melibatkan manajemen memori kompleks, optimasi penggunaan buffer, dan integrasi dengan subsistem socket kernel, sambil mendukung fitur seperti fixed buffers, polling, dan notifikasi.

### nop.c
Mengimplementasikan operasi NOP (no operation) dalam io_uring pada kernel Linux yang secara teknis memungkinkan pengguna untuk mengirim permintaan dummy melalui io_uring tanpa melakukan I/O nyata, namun tetap menguji jalur eksekusi dan parameter tertentu. Struktur io_nop menyimpan parameter seperti file descriptor, flags, dan hasil simulasi, sedangkan fungsi io_nop_prep mempersiapkan permintaan dengan membaca nilai-nilai dari submission queue entry (SQE) dan mengevaluasi flag tertentu untuk memutuskan apakah akan menyuntikkan hasil, menggunakan file tetap, atau buffer tetap. Fungsi io_nop kemudian menangani eksekusi permintaan NOP tersebut, mengelola pengambilan file dan buffer sesuai flag yang disetel, dan menetapkan hasil ke permintaan, dengan menangani kesalahan jika parameter tidak valid.

### notif.c
Menangani alur kerja zero-copy notification dalam konteks io_uring melalui struktur io_notif_data, yang berfungsi mengelola buffer pengguna (ubuf_info) dan menyinkronkan penyelesaian tugas-tugas asinkron saat data dikirim melalui jaringan. Struktur dan fungsi yang disediakan memungkinkan penggabungan beberapa notifikasi dalam satu task work dan memastikan manajemen memori serta pelaporan status transfer data seperti apakah zero-copy berhasil digunakan atau tidak. Mekanisme ini terintegrasi dengan sk_buff dan menggunakan callback yang terdaftar di ubuf_info_ops untuk menyelesaikan notifikasi, dengan perlakuan khusus terhadap referensi dan urutan task yang dieksekusi saat buffer telah tidak digunakan lagi.

### opdef.c
Bertugas sebagai tabel pemetaan opcode io_uring ke handler-nya masing-masing, dengan setiap entri dalam array io_issue_defs[] mendeskripsikan atribut teknis spesifik yang dibutuhkan seperti kebutuhan file, dukungan iopoll, penanganan prep dan issue function, serta alokasi struktur asinkron jika diperlukan; tabel ini memungkinkan kernel Linux untuk mengeksekusi berbagai operasi asynchronous secara efisien dan fleksibel, di mana masing-masing entri seperti IORING_OP_READV, IORING_OP_WRITEV, atau IORING_OP_TIMEOUT dipetakan langsung ke fungsi-fungsi penangan spesifik seperti io_read, io_write, atau io_timeout, sehingga mendukung performa tinggi dan kemampuan konfigurasi modular dalam sistem IO modern.

### openclose.c
Menangani operasi pembukaan dan penutupan file melalui antarmuka io_uring, dengan struktur utama seperti io_open, io_close, dan io_fixed_install yang merepresentasikan konteks masing-masing operasi. Fungsi-fungsi seperti io_openat, io_close, dan io_install_fixed_fd mengatur logika spesifik termasuk alokasi file descriptor, penanganan flag seperti O_CLOEXEC, serta sinkronisasi dan validasi yang ketat terhadap parameter dari submission queue entries (SQE). Penanganan asinkron, validasi kredensial, dan manajemen sumber daya (seperti fixed file slots) dilakukan secara hati-hati untuk memastikan integritas sistem dan kompatibilitas dengan model non-blok io_uring.

### poll.c
Mengelola polling dalam konteks operasi I/O asinkron menggunakan io_uring di kernel Linux. Kode ini bertanggung jawab untuk memeriksa dan menangani peristiwa polling, mengelola referensi objek terkait polling, dan memastikan bahwa proses polling dapat berjalan dengan benar melalui berbagai mekanisme, termasuk penanganan penghapusan entri, pengelolaan antrian tunggu, serta eksekusi tugas terkait polling. Selain itu, kode ini juga mengelola pengaturan status polling, baik itu untuk polling tunggal atau ganda, serta menangani pengelolaan kepemilikan sumber daya untuk memastikan tidak terjadi kondisi balapan.

### register.c
Mengelola pendaftaran dan pengaturan berbagai aspek dari io_uring, sebuah antarmuka sistem yang memungkinkan aplikasi untuk melakukan operasi I/O secara efisien menggunakan pemrograman berbasis antrian. Beberapa fungsi utama dalam kode ini meliputi registrasi dan pembatalan pendaftaran untuk berbagai jenis operasi, seperti pendaftaran untuk kepribadian tertentu (io_register_personality), pengaturan batasan operasi (io_register_restrictions), dan pengelolaan ukuran antrian serta sumber daya terkait (io_register_resize_rings). Kode ini juga menangani pengaturan afinitas CPU untuk pengolahan antrian I/O (io_register_iowq_aff). Secara keseluruhan, kode ini mengatur dan mengoptimalkan bagaimana operasi I/O dilakukan melalui io_uring, termasuk pengaturan sumber daya memori, pengendalian antrian, dan pengelolaan tugas dengan cara yang efisien.

### rsrc.c
Mengelola dan memperbarui sumber daya dalam konteks io_uring, yang merupakan antarmuka I/O asinkron di Linux. Kode ini menangani pendaftaran dan pembaruan file, buffer, dan sumber daya lainnya dalam sistem I/O, termasuk alokasi dan pembebasan memori yang terkait. Fungsi-fungsi yang ada, seperti io_account_mem dan io_buffer_validate, memastikan bahwa memori dan sumber daya I/O dikelola dengan benar, mencegah over-penyalahgunaan dan memastikan bahwa alokasi memori dilakukan sesuai dengan batasan yang ada. Selain itu, ada juga pengelolaan struktur data untuk buffer dan file, serta proses validasi dan penghitungan yang terkait dengan memori yang teralokasi, sehingga sistem tetap efisien dan aman dalam menangani operasi I/O.

### rw.c
Mengelola operasi baca/tulis (read/write) dengan menggunakan io_uring untuk melakukan input/output asinkron. Kode ini mengatur bagaimana buffer data disiapkan dan diimpor untuk operasi baca/tulis, serta bagaimana menyelesaikan operasi tersebut setelah selesai. Struktur data io_rw digunakan untuk menyimpan informasi terkait operasi I/O, seperti alamat buffer dan panjang data. Fungsi-fungsi seperti io_complete_rw dan io_req_rw_cleanup bertanggung jawab untuk menyelesaikan dan membersihkan sumber daya setelah operasi I/O selesai. Selain itu, kode ini juga mendukung pengolahan I/O dengan berbagai jenis buffer, termasuk buffer yang dipilih pengguna atau yang telah ditentukan sebelumnya.

### splice.c
Menangani operasi splice dan tee dalam io_uring yang memungkinkan transfer data antara dua file atau buffer tanpa melalui buffer pengguna. Fungsi io_splice dan io_tee bertanggung jawab untuk mempersiapkan, menjalankan, dan membersihkan operasi splice dan tee yang dilakukan dengan menggunakan file descriptor, yang dapat terhubung ke sumber data melalui io_splice_get_file. Struktur io_splice menyimpan informasi penting terkait file input dan output, offset, panjang data, dan flag, serta memastikan bahwa operasi tersebut dieksekusi secara asinkron dengan penanganan kegagalan yang sesuai. Fungsi-fungsi pendukung, seperti __io_splice_prep, memastikan validitas parameter yang diterima sebelum melanjutkan eksekusi operasi tersebut.

### sqpoll.c
Mengelola polling sisi pengajuan pada antrian pengajuan (SQ) dalam io_uring, yang memungkinkan aplikasi untuk mengelola operasi I/O secara efisien. Kode ini mencakup logika untuk mengelola thread yang bertanggung jawab atas polling dan pengajuan permintaan I/O, mengatur thread untuk berhenti atau diparkir, serta menangani keadaan di mana thread perlu di-unpark atau diberhentikan. Selain itu, kode ini juga mencakup pengelolaan sumber daya terkait dengan data yang terkait dengan polling, seperti pengaturan afinitas CPU, penanganan sinyal, dan pembaruan waktu kerja. Fungsi-fungsi tersebut bekerja bersama untuk mengoptimalkan pengelolaan beban kerja I/O dengan membagi tugas-tugas ini di antara beberapa thread atau CPU secara efisien.

### statx.c
Menangani operasi statx dalam konteks I/O asinkron menggunakan io_uring. Fungsi io_statx_prep mempersiapkan permintaan dengan mengambil informasi dari struktur io_uring_sqe, seperti file descriptor, path, dan buffer untuk hasil statx. Kemudian, fungsi io_statx melakukan operasi statx nyata melalui do_statx, yang mengambil metadata file berdasarkan parameter yang diberikan. Fungsi io_statx_cleanup bertanggung jawab untuk membersihkan sumber daya, seperti melepaskan nama file yang diambil. Kode ini memanfaatkan fitur io_uring untuk meningkatkan efisiensi I/O asinkron pada sistem Linux.

### sync.c
Menangani operasi sinkronisasi file dan alokasi ruang file secara asinkron menggunakan API io_uring di Linux. Kode ini melibatkan beberapa fungsi seperti io_sfr_prep untuk mempersiapkan parameter operasi sinkronisasi, io_sync_file_range dan io_fsync untuk melakukan sinkronisasi data atau metadata file ke disk, serta io_fallocate untuk mengalokasikan ruang kosong pada file. Semua operasi ini dilakukan dalam konteks pemrograman asinkron dengan memastikan bahwa beberapa operasi blok, seperti sinkronisasi dan alokasi file, dieksekusi dengan benar dalam konteks yang memerlukan pemblokiran (blocking context), sementara operasi lainnya dapat dilakukan secara non-blocking.

### tctx.c
Menangani pendaftaran dan pengelolaan sumber daya io_uring. Fungsi utama yang terlibat meliputi alokasi dan pengelolaan konteks tugas (task_context), pengaturan antrian kerja I/O, serta pendaftaran dan penghapusan file descriptor (fd) dalam konteks ini. Fungsi seperti io_ringfd_register dan io_ringfd_unregister mengelola pendaftaran dan penghapusan file descriptor yang terdaftar pada ring I/O, sementara fungsi io_uring_alloc_task_context bertanggung jawab untuk mengalokasikan dan menginisialisasi konteks tugas yang terkait dengan setiap proses. Selain itu, terdapat pengelolaan memori yang hati-hati menggunakan mutex untuk menghindari kondisi balapan, serta penanganan kesalahan alokasi memori dengan cara yang aman.

### timeout.c
Menangani mekanisme timeout dalam konteks I/O pada sistem yang menggunakan io_uring. Struktur dan fungsi dalam kode ini mengelola waktu tunggu (timeout) yang terkait dengan permintaan I/O, memungkinkan untuk penjadwalan dan pembatalan timeout, serta pembaruan atau penghapusan timeout yang sudah ada. Fungsi utama seperti io_timeout_fn dan io_timeout_complete berfokus pada pemrosesan dan penyelesaian timeout, sementara io_flush_timeouts memastikan bahwa timeout yang sudah tidak berlaku lagi dihapus atau diselesaikan dengan benar. Selain itu, kode ini juga menangani pembaruan atau pembatalan timeout yang terkait dengan tugas I/O yang lebih kompleks, seperti timeout berulang atau terkait dengan linked task.

### truncate.c
Mengelola operasi pemotongan ukuran file (truncate) dalam konteks io_uring. Struktur io_ftrunc menyimpan pointer ke file dan panjang baru file, yang akan digunakan dalam operasi ftruncate. Fungsi io_ftruncate_prep bertugas memvalidasi parameter dari io_uring_sqe, memastikan tidak ada flag atau field yang tidak sesuai, serta menyimpan offset sebagai panjang baru file. Fungsi io_ftruncate kemudian memanggil do_ftruncate untuk melakukan pemotongan file dan menyimpan hasilnya dalam request. Operasi ini dipaksa berjalan secara asinkron melalui flag REQ_F_FORCE_ASYNC, yang menandakan bahwa meskipun permintaan terlihat sederhana, ia tetap diproses melalui jalur asynchronous io_uring.

### uring_cmd.c
Sebagai pengelola utama alur eksekusi dan penanganan perintah io_uring_cmd di kernel Linux, menyediakan kerangka kerja bagi perangkat lunak tingkat pengguna untuk melakukan operasi I/O yang kompleks secara asynchronous dan efisien melalui antarmuka io_uring, secara teknis, ia menangani alokasi dan pembersihan data perintah asynchronous, pengaturan flags dan SQE, pendaftaran perintah sebagai cancelable, eksekusi deferred melalui task_work, serta integrasi dengan sistem keamanan dan subsistem jaringan seperti sockopt, dan semuanya dilakukan dengan pemisahan logika antara perintah biasa dan perintah dengan polling I/O, menjadikannya komponen penting dalam mendukung fleksibilitas dan performa tinggi pada subsistem io_uring.

### waitid.c
Mengimplementasikan dukungan asynchronous pada sistem waitid() dalam konteks io_uring, dengan tujuan memungkinkan proses menunggu perubahan status anak (seperti keluar atau berhenti) secara non-blocking. Modul ini mencakup struktur data io_waitid dan io_waitid_async yang menyimpan informasi proses yang ditunggu dan status sinyal, serta menyediakan mekanisme callback dan cancelation melalui antrian tugas (task_work) dan wait queue. Proses penanganan disesuaikan untuk konteks kompatibilitas (32-bit) dan menangani skenario seperti interupsi sinyal (-ERESTARTSYS) serta pembatalan operasi yang sedang aktif.

### xattr.c
Menangani operasi extended attributes (xattr) dengan menyediakan implementasi fungsi untuk mempersiapkan dan menjalankan pengambilan (getxattr) serta penyetelan atribut (setxattr) pada file descriptor langsung (fgetxattr/fsetxattr) maupun berdasarkan path (getxattr/setxattr), struktur io_xattr digunakan sebagai konteks yang menyimpan informasi terkait file, nama atribut, nilai atribut, dan flag, sedangkan proses pembersihan memori dialokasikan secara eksplisit melalui io_xattr_cleanup, dan eksekusi fungsi-fungsi utama dilakukan secara sinkron meskipun dipaksakan sebagai asynchronous melalui flag REQ_F_FORCE_ASYNC, dengan hasil akhir operasi disimpan menggunakan io_req_set_res.

### zcrx.c
Implementasi zero-copy receive queue (ZCRX) dalam io_uring yang memungkinkan aplikasi user space menerima data jaringan langsung ke buffer tanpa perlu penyalinan data tambahan antar ruang kernel dan user, secara teknis ia memetakan area memori pengguna, mem-pin halaman, dan memetakan/demapping buffer dengan DMA melalui dma_map_page_attrs dan dma_unmap_page_attrs, serta mengelola referensi buffer menggunakan struktur net_iov, dengan sinkronisasi dilakukan melalui spinlock dan atomic counter, di mana integrasi dengan jaringan dilakukan dengan membuka RX queue perangkat jaringan melalui memory provider ops khusus.

## Headers
### advice.h
Just declare the function specification. 
